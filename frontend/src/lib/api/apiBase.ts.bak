/** apiBase.ts — base URL + endpoint discovery (ready, guest, gen-jwt, credits, usage) */
let _base: string | null = null;
let _eps: ApiEndpoints | null = null;

export type ApiEndpoints = {
  ready?: string;
  guestAuth?: string;
  genJwt?: string;
  credits?: string;
  usage?: string;
};

export function apiUrl(path = ""): string {
  const base = _base ?? "";
  if (!path) return base || "/";
  if (path.startsWith("http")) return path;
  // ensure single slash join
  const left = base.replace(/\/+$/,"");
  const right = path.replace(/^\/+/,"");
  return left ? `${left}/${right}` : `/${right}`;
}

export async function ensureApiBase(): Promise<string> {
  if (_base !== null) return _base;
  // In dev we rely on Vite proxy; use relative paths.
  // In prod (Pages) same-origin also works due to Pages → API routing.
  _base = "";
  // Optional: allow manual override via localStorage for debugging
  try {
    const manual = localStorage.getItem("api_base_override");
    if (manual && manual.trim()) _base = manual.trim();
  } catch {}
  return _base;
}

async function exists(path: string, method: "GET" | "POST" = "GET"): Promise<boolean> {
  try {
    const r = await fetch(apiUrl(path), {
      method,
      headers: { Accept: "application/json" }
    });
    // treat 200/204/401/405 as "endpoint exists"
    return [200,204,401,405].includes(r.status);
  } catch {
    return false;
  }
}

export async function ensureApiEndpoints(): Promise<ApiEndpoints> {
  if (_eps) return _eps;
  await ensureApiBase();

  const pick = async (cands: string[], method: "GET" | "POST" = "GET") => {
    for (const p of cands) if (await exists(p, method)) return p;
    return undefined;
  };

  const ready = await pick(
    ["/api/v1/healthz","/api/healthz","/api/health","/healthz","/health","/ready","/api/ready"]
  );

  const guestAuth = await pick(
    ["/auth/guest","/api/v1/auth/guest"], "POST"
  );

  const genJwt = await pick(
    [ ], "GET"
  );

  const credits = await pick(
    ["/api/credits","/v1/credits","/credits","/api/v1/credits"]
  );

  // NEW: usage candidates — matches your Worker routes
  const usage = await pick(
    ["/api/billing/usage","/billing/usage","/api/v1/usage","/api/usage","/usage","/api/v1/billing/usage"]
  );

  _eps = { ready, guestAuth, genJwt, credits, usage };
  return _eps;
}

export async function fetchJson<T = any>(path: string, init?: RequestInit): Promise<{ ok: boolean; status: number; data: T | string | null; }> {
  const r = await fetch(apiUrl(path), {
    credentials: "include",
    ...init,
    headers: { Accept: "application/json", ...(init?.headers || {}) }
  });
  const ct = r.headers.get("content-type") || "";
  const data = ct.includes("application/json") ? await r.json() : (await r.text() || null);
  return { ok: r.ok, status: r.status, data };
}
// ---- legacy exports for existing imports ----
export function apiBase(path: string = "") { return apiUrl(path); }
export function currentApiBase(): string { return _base ?? ""; }
// ---- auth helpers used by App.tsx ----
export function readPackedToken(): { token: string; exp?: number } | null {
  try {
    const raw = localStorage.getItem("cog_auth_jwt");
    if (!raw) return null;
    const j = JSON.parse(raw);
    if (j && typeof j.token === "string") return j;
  } catch {}
  const legacy = localStorage.getItem("jwt") || localStorage.getItem("guest_token");
  if (legacy && legacy.trim()) return { token: legacy };
  return null;
}

function b64uToUtf8(s: string): string {
  // base64url -> base64
  s = s.replace(/-/g, "+").replace(/_/g, "/");
  // pad to multiple of 4
  const pad = s.length % 4 ? 4 - (s.length % 4) : 0;
  if (pad) s = s + "=".repeat(pad);
  try { return atob(s); } catch { return ""; }
}

export function readUserEmail(): string | null {
  const packed = readPackedToken();
  const tok = packed?.token;
  if (!tok) return null;
  const parts = tok.split(".");
  if (parts.length < 2) return null;
  try {
    const payloadJson = b64uToUtf8(parts[1]);
    const p = JSON.parse(payloadJson);
    const email = p?.email ?? p?.em ?? p?.sub ?? null;
    return typeof email === "string" ? email : null;
  } catch { return null; }
}
/** Build Authorization + Accept headers from stored JWT (guest or user). */
export function authHeaders(init: HeadersInit = {}): HeadersInit {
  const h = new Headers(init as any);
  if (!h.has("Accept")) h.set("Accept", "application/json");
  try {
    const packed = (typeof (globalThis as any).readPackedToken === "function")
      ? (globalThis as any).readPackedToken()
      : (typeof readPackedToken === "function" ? readPackedToken() : null);

    let token: string | undefined =
      (packed && typeof packed.token === "string") ? packed.token :
      (localStorage.getItem("jwt") || localStorage.getItem("guest_token") || undefined) as string | undefined;

    token = (token || "").trim();
    if (token && !h.has("Authorization")) h.set("Authorization", `Bearer ${token}`);
  } catch { /* no-op */ }
  return Object.fromEntries(h.entries());
}



